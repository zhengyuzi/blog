const t='{"documentCount":8,"nextId":8,"documentIds":{"0":"/blog/JavaScript/内存泄漏.html#内存泄漏","1":"/blog/JavaScript/内存泄漏.html#什么是内存泄漏","2":"/blog/JavaScript/内存泄漏.html#常见的内存泄漏","3":"/blog/JavaScript/内存泄漏.html#闭包使用不当","4":"/blog/JavaScript/内存泄漏.html#全局变量","5":"/blog/JavaScript/内存泄漏.html#游离的dom节点","6":"/blog/JavaScript/内存泄漏.html#遗忘的定时器","7":"/blog/JavaScript/内存泄漏.html#控制台的打印"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,16],"1":[1,1,15],"2":[1,1,1],"3":[1,2,42],"4":[1,2,36],"5":[1,2,48],"6":[1,2,18],"7":[1,2,5]},"averageFieldLength":[1,1.625,22.625],"storedFields":{"0":{"title":"内存泄漏","titles":[]},"1":{"title":"什么是内存泄漏","titles":["内存泄漏"]},"2":{"title":"常见的内存泄漏","titles":["内存泄漏"]},"3":{"title":"闭包使用不当","titles":["内存泄漏","常见的内存泄漏"]},"4":{"title":"全局变量","titles":["内存泄漏","常见的内存泄漏"]},"5":{"title":"游离的DOM节点","titles":["内存泄漏","常见的内存泄漏"]},"6":{"title":"遗忘的定时器","titles":["内存泄漏","常见的内存泄漏"]},"7":{"title":"控制台的打印","titles":["内存泄漏","常见的内存泄漏"]}},"dirtCount":0,"index":[["一定要及时清理掉输出",{"2":{"7":1}}],["可以使用控制台打印便于调试",{"2":{"7":1}}],["控制台的打印",{"0":{"7":1}}],["来取消使用",{"2":{"6":1}}],["也存在这个问题",{"2":{"6":1}}],["也就会出现内存泄漏",{"2":{"5":1}}],["也就造成了内存泄漏",{"2":{"3":1}}],["也就是说当我们在使用全局变量存储数据时",{"2":{"4":1}}],["也就是说",{"2":{"3":1}}],["浏览器中的",{"2":{"6":1}}],["另外",{"2":{"6":1}}],["cancelanimationframe",{"2":{"6":1}}],["cleartimeout来清除",{"2":{"6":1}}],["clearinterval",{"2":{"6":1}}],["console",{"2":{"3":3}}],["最好调用",{"2":{"6":1}}],["时",{"2":{"6":1}}],["时会使用变量缓存",{"2":{"5":1}}],["timeout",{"2":{"6":1}}],["test",{"2":{"3":10,"4":2}}],["或者",{"2":{"6":2}}],["interval",{"2":{"6":1}}],["id=",{"2":{"5":3}}],["回调函数里的变量以及回调函数本身都无法被回收",{"2":{"6":1}}],["遗忘的定时器",{"0":{"6":1}}],["解决办法就是将引用子节点的变量也置空",{"2":{"5":1}}],["还是会出现内存泄漏",{"2":{"5":1}}],["假如我们将父节点置空",{"2":{"5":1}}],["gc",{"2":{"5":1}}],["依然进行不了",{"2":{"5":1}}],["节点树下整个游离节点树均无法清理",{"2":{"5":1}}],["节点引用后删除了节点",{"2":{"5":1}}],["节点的引用",{"2":{"5":1}}],["当不需要",{"2":{"6":1}}],["当我们使用变量缓存",{"2":{"5":1}}],["当然也很简单",{"2":{"4":1}}],["已无变量引用",{"2":{"5":1}}],["虽置空了ul变量",{"2":{"5":1}}],["整个ul及其子元素都不能gc",{"2":{"5":1}}],["由于ul变量存在",{"2":{"5":1}}],["queryselector",{"2":{"5":3}}],["script>",{"2":{"5":2}}],["something",{"2":{"4":1}}],["ul>",{"2":{"5":1}}],["ul",{"2":{"5":6}}],[">",{"2":{"5":3}}],["requestanimationframe",{"2":{"6":1}}],["removechild",{"2":{"5":1}}],["return",{"2":{"3":6}}],["root",{"2":{"5":4}}],["div>",{"2":{"5":1}}],["div",{"2":{"5":1}}],["document",{"2":{"5":3}}],["dom",{"2":{"5":4}}],["do",{"2":{"4":1}}],["x3c",{"2":{"5":14}}],["html",{"2":{"5":1}}],["否则游离的子树无法释放",{"2":{"5":1}}],["但是在生产环境下",{"2":{"7":1}}],["但是被删除的父节点其子节点引用也缓存在变量里",{"2":{"5":1}}],["但是它并没有造成内存泄漏",{"2":{"3":1}}],["但由于li3变量引用ul的子节点",{"2":{"5":1}}],["但移除节点的时候",{"2":{"5":1}}],["考虑到性能或代码简洁方面",{"2":{"5":1}}],["游离的dom节点",{"0":{"5":1}}],["不然的话数据量越来越大",{"2":{"4":1}}],["我们需要在不需要的时候用",{"2":{"6":1}}],["我们应该同步释放缓存的引用",{"2":{"5":1}}],["我们代码中进行",{"2":{"5":1}}],["我们一定要记得设置存储上限并及时清理",{"2":{"4":1}}],["我们在程序中也会不可避免的使用全局变量",{"2":{"4":1}}],["特别是在使用全局变量做持续存储大量数据的缓存时",{"2":{"4":1}}],["即可",{"2":{"4":1}}],["即访问并使用变量",{"2":{"0":1}}],["在开发环境下",{"2":{"7":1}}],["在定时器没有结束前",{"2":{"6":1}}],["在使用完将其置为",{"2":{"4":1}}],["在声明变量",{"2":{"0":1}}],["要确保使用后将其置空或者重新分配",{"2":{"4":1}}],["这也就需要我们额外的关注",{"2":{"4":1}}],["这些全局变量除非被取消或者重新分配之外也是无法回收的",{"2":{"4":1}}],["这一现象就被称为内存泄漏",{"2":{"1":1}}],["又因为是全局变量",{"2":{"4":1}}],["此时可以gc",{"2":{"5":1}}],["此时这种情况就会在全局自动创建一个变量name",{"2":{"4":1}}],["此处变量name未被声明",{"2":{"4":1}}],["就会导致该变量在全局创建",{"2":{"4":1}}],["却直接对某变量进行赋值",{"2":{"4":1}}],["例如未声明变量",{"2":{"4":1}}],["只是有时候会因为疏忽而导致某些变量流失到全局",{"2":{"4":1}}],["全局的变量一般是不会被垃圾回收掉的当然这并不是说变量都不能存在全局",{"2":{"4":1}}],["全局变量",{"0":{"4":1}}],["name",{"2":{"4":1}}],["null",{"2":{"3":1,"4":2,"5":2}}],["new",{"2":{"3":3,"4":2}}],["如果不将缓存引用的变量置空",{"2":{"5":1}}],["如果某一块内存空间在使用后未被释放",{"2":{"1":1}}],["如上所示",{"2":{"5":1}}],["如下所示",{"2":{"4":1}}],["如下",{"2":{"3":1}}],["把外部的引用关系置空就好了",{"2":{"3":1}}],["其实在函数调用后",{"2":{"3":1}}],["那么就会导致整个父",{"2":{"5":1}}],["那么怎样解决呢",{"2":{"3":1}}],["那我们再来看",{"2":{"3":1}}],["并将一个很大的数组赋值给name",{"2":{"4":1}}],["并不会被回收",{"2":{"3":1}}],["并且因为",{"2":{"3":1}}],["并且持续累积",{"2":{"1":1}}],["并且在不使用变量的时候",{"2":{"1":1}}],["所以ul元素依然不能被gc",{"2":{"5":1}}],["所以该内存空间就一直不会被释放",{"2":{"4":1}}],["所以",{"2":{"3":1}}],["变量引用",{"2":{"3":1}}],["变量完全是可以被回收的",{"2":{"3":1}}],["中的",{"2":{"3":1}}],["的函数中存在函数",{"2":{"3":1}}],["显然它也是闭包",{"2":{"3":1}}],["内部的",{"2":{"3":1}}],["内存压力也会随之增高",{"2":{"4":1}}],["内存使用完毕后",{"2":{"0":1}}],["内存使用",{"2":{"0":1}}],["内存分配",{"2":{"0":1}}],["内存其实就是程序在运行时",{"2":{"0":1}}],["内存泄漏",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1}}],["因为返回的函数中并没有对",{"2":{"3":1}}],["上面这个例子是一个典型闭包",{"2":{"3":1}}],["ok",{"2":{"3":1}}],["li3",{"2":{"5":4}}],["li",{"2":{"5":1}}],["li>",{"2":{"5":7}}],["log",{"2":{"3":3}}],["let",{"2":{"3":6,"5":3}}],["yu",{"2":{"3":3}}],["fn2child",{"2":{"3":5}}],["fn2",{"2":{"3":5}}],["fn1child",{"2":{"3":2}}],["fn1",{"2":{"3":4,"4":2}}],["function",{"2":{"3":3}}],["fill",{"2":{"3":3}}],["10000",{"2":{"4":2}}],["1000",{"2":{"3":3}}],["array",{"2":{"3":3,"4":2}}],["=",{"2":{"3":7,"4":3,"5":5}}],["javascriptvar",{"2":{"4":1}}],["javascriptfunction",{"2":{"3":3,"4":1}}],["javascript同大多数现代编程语言一样",{"2":{"1":1}}],["闭包使用不当可能会造成内存泄漏",{"2":{"3":1}}],["闭包使用不当",{"0":{"3":1}}],["常见的内存泄漏",{"0":{"2":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1}}],["直观体现就是程序卡死",{"2":{"1":1}}],["直至用尽全部的内存空间",{"2":{"1":1}}],["程序将无法正常运行",{"2":{"1":1}}],["导致未释放的内存空间越积越多",{"2":{"1":1}}],["每一个程序的运行都需要一块内存空间",{"2":{"1":1}}],["每一块内存都有对应的生命周期",{"2":{"0":1}}],["自动",{"2":{"1":1}}],["都实现了给变量自动分配内存",{"2":{"1":1}}],["什么是内存泄漏",{"0":{"1":1}}],["释放掉不再被使用的内存",{"2":{"0":1}}],["释放内存",{"2":{"0":1,"1":1}}],["函数",{"2":{"3":1}}],["函数内部的引用",{"2":{"3":1}}],["函数等",{"2":{"0":1}}],["函数时",{"2":{"0":1}}],["写操作",{"2":{"0":1}}],["对分配到的内存进行读",{"2":{"0":1}}],["系统崩溃",{"2":{"1":1}}],["系统分配的内存空间",{"2":{"0":1}}],["系统为其分配的一块存储空间",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
