const t='{"documentCount":22,"nextId":22,"documentIds":{"0":"/blog/JavaScript/内存泄漏.html#内存泄漏","1":"/blog/JavaScript/内存泄漏.html#什么是内存泄漏","2":"/blog/JavaScript/内存泄漏.html#常见的内存泄漏","3":"/blog/JavaScript/内存泄漏.html#闭包使用不当","4":"/blog/JavaScript/内存泄漏.html#全局变量","5":"/blog/JavaScript/内存泄漏.html#游离的dom节点","6":"/blog/JavaScript/内存泄漏.html#遗忘的定时器","7":"/blog/JavaScript/内存泄漏.html#控制台的打印","8":"/blog/JavaScript/深拷贝与浅拷贝.html#深拷贝与浅拷贝","9":"/blog/JavaScript/深拷贝与浅拷贝.html#赋值和深-浅拷贝的区别","10":"/blog/JavaScript/深拷贝与浅拷贝.html#浅拷贝的实现方式","11":"/blog/JavaScript/深拷贝与浅拷贝.html#object-assign","12":"/blog/JavaScript/深拷贝与浅拷贝.html#展开运算符","13":"/blog/JavaScript/深拷贝与浅拷贝.html#array-prototype-concat","14":"/blog/JavaScript/深拷贝与浅拷贝.html#array-prototype-slice","15":"/blog/JavaScript/深拷贝与浅拷贝.html#深拷贝的实现方式","16":"/blog/JavaScript/深拷贝与浅拷贝.html#json-parse-json-stringify","17":"/blog/JavaScript/深拷贝与浅拷贝.html#手写","18":"/blog/JavaScript/闭包.html#闭包","19":"/blog/JavaScript/闭包.html#什么是闭包","20":"/blog/JavaScript/闭包.html#闭包产生的必要条件","21":"/blog/JavaScript/闭包.html#闭包的作用"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,16],"1":[1,1,15],"2":[1,1,1],"3":[1,2,42],"4":[1,2,36],"5":[1,2,48],"6":[1,2,18],"7":[1,2,5],"8":[1,1,34],"9":[2,1,29],"10":[1,1,1],"11":[3,2,21],"12":[2,2,24],"13":[4,2,15],"14":[4,2,15],"15":[1,1,1],"16":[4,2,19],"17":[1,2,1],"18":[1,1,5],"19":[1,1,14],"20":[1,1,19],"21":[1,1,27]},"averageFieldLength":[1.5909090909090908,1.5,18.454545454545453],"storedFields":{"0":{"title":"内存泄漏","titles":[]},"1":{"title":"什么是内存泄漏","titles":["内存泄漏"]},"2":{"title":"常见的内存泄漏","titles":["内存泄漏"]},"3":{"title":"闭包使用不当","titles":["内存泄漏","常见的内存泄漏"]},"4":{"title":"全局变量","titles":["内存泄漏","常见的内存泄漏"]},"5":{"title":"游离的DOM节点","titles":["内存泄漏","常见的内存泄漏"]},"6":{"title":"遗忘的定时器","titles":["内存泄漏","常见的内存泄漏"]},"7":{"title":"控制台的打印","titles":["内存泄漏","常见的内存泄漏"]},"8":{"title":"深拷贝与浅拷贝","titles":[]},"9":{"title":"赋值和深/浅拷贝的区别","titles":["深拷贝与浅拷贝"]},"10":{"title":"浅拷贝的实现方式","titles":["深拷贝与浅拷贝"]},"11":{"title":"Object.assign()","titles":["深拷贝与浅拷贝","浅拷贝的实现方式"]},"12":{"title":"展开运算符 ...","titles":["深拷贝与浅拷贝","浅拷贝的实现方式"]},"13":{"title":"Array.prototype.concat()","titles":["深拷贝与浅拷贝","浅拷贝的实现方式"]},"14":{"title":"Array.prototype.slice()","titles":["深拷贝与浅拷贝","浅拷贝的实现方式"]},"15":{"title":"深拷贝的实现方式","titles":["深拷贝与浅拷贝"]},"16":{"title":"JSON.parse(JSON.stringify())","titles":["深拷贝与浅拷贝","深拷贝的实现方式"]},"17":{"title":"手写","titles":["深拷贝与浅拷贝","深拷贝的实现方式"]},"18":{"title":"闭包","titles":[]},"19":{"title":"什么是闭包","titles":["闭包"]},"20":{"title":"闭包产生的必要条件","titles":["闭包"]},"21":{"title":"闭包的作用","titles":["闭包"]}},"dirtCount":0,"index":[["性能损耗等",{"2":{"21":1}}],["可能会导致一些问题",{"2":{"21":1}}],["可以使用控制台打印便于调试",{"2":{"7":1}}],["合理利用闭包可以提高代码的可读性和灵活性",{"2":{"21":1}}],["避免滥用",{"2":{"21":1}}],["谨慎使用",{"2":{"21":1}}],["会导致内存泄漏",{"2":{"21":1}}],["会相互影响",{"2":{"9":1}}],["导致外部作用域的变量无法被垃圾回收机制释放",{"2":{"21":1}}],["导致未释放的内存空间越积越多",{"2":{"1":1}}],["需要注意的是",{"2":{"21":1}}],["使得函数可以更加灵活地组合和使用",{"2":{"21":1}}],["使得函数可以在之后的调用中继续使用这些状态",{"2":{"21":1}}],["高阶函数的参数和返回值",{"2":{"21":1}}],["实现了一种类似于私有变量的效果",{"2":{"21":1}}],["实现私有变量",{"2":{"21":1}}],["实现深拷贝",{"2":{"16":1}}],["包括变量的值和状态",{"2":{"21":1}}],["仍然保持外部函数的状态",{"2":{"21":1}}],["保持状态",{"2":{"21":1}}],["嵌套的内部函数必须被执行",{"2":{"20":1}}],["嵌套的内部函数必须引用在外部函数中定义的变量",{"2":{"20":1}}],["存在函数嵌套",{"2":{"20":1}}],["概述上面的话",{"2":{"19":1}}],["mdn对闭包的定义为",{"2":{"19":1}}],["红宝书上对于闭包的定义",{"2":{"19":1}}],["中对闭包的定义",{"2":{"19":1}}],["中的",{"2":{"3":1}}],["忍者秘籍",{"2":{"19":1}}],["什么是闭包",{"0":{"19":1}}],["什么是内存泄漏",{"0":{"1":1}}],["垃圾回收机制",{"2":{"18":1}}],["执行上下文",{"2":{"18":1}}],["闭包保留了对外部作用域的引用",{"2":{"21":1}}],["闭包可以作为高阶函数的参数或返回值",{"2":{"21":1}}],["闭包可以在函数内部创建局部变量",{"2":{"21":1}}],["闭包可以在函数执行完毕后",{"2":{"21":1}}],["闭包的作用",{"0":{"21":1}}],["闭包产生的必要条件",{"0":{"20":1}}],["闭包是指有权访问另一个函数作用域中变量的函数",{"2":{"19":1}}],["闭包是指有权访问另外一个函数作用域中的变量的函数",{"2":{"19":1}}],["闭包是指那些能够访问自由变量的函数",{"2":{"19":1}}],["闭包允许函数访问并操作函数外部的变量",{"2":{"19":1}}],["闭包",{"0":{"18":1},"1":{"19":1,"20":1,"21":1}}],["闭包使用不当可能会造成内存泄漏",{"2":{"3":1}}],["闭包使用不当",{"0":{"3":1}}],["手写",{"0":{"17":1}}],["了",{"2":{"16":1}}],["得到的函数就不再是函数",{"2":{"16":1}}],["得到的正则就不再是正则",{"2":{"16":1}}],["变为null",{"2":{"16":1}}],["变为空对象",{"2":{"16":1}}],["变量引用",{"2":{"3":1}}],["变量完全是可以被回收的",{"2":{"3":1}}],["而且对象会开辟新的栈",{"2":{"16":1}}],["而不是堆中的数据",{"2":{"9":1}}],["而不复制对象本身",{"2":{"8":1}}],["一去一来",{"2":{"16":1}}],["一定要及时清理掉输出",{"2":{"7":1}}],["再用json",{"2":{"16":1}}],["js",{"2":{"19":1}}],["json",{"0":{"16":2}}],["javascriptconst",{"2":{"11":1,"12":1,"13":1,"14":1}}],["javascriptvar",{"2":{"4":1,"8":1}}],["javascriptfunction",{"2":{"3":3,"4":1,"20":1}}],["javascript同大多数现代编程语言一样",{"2":{"1":1}}],["2",{"2":{"13":1,"14":1,"20":1}}],["200",{"2":{"12":2}}],["username",{"2":{"13":3,"14":3}}],["ul>",{"2":{"5":1}}],["ul",{"2":{"5":6}}],["3",{"2":{"13":2,"14":2,"20":1}}],["1",{"2":{"13":2,"14":2,"20":1}}],["100",{"2":{"12":3}}],["10000",{"2":{"4":2}}],["1000",{"2":{"3":3}}],["p90",{"2":{"19":1}}],["parse处理后",{"2":{"16":1}}],["parse把字符串解析成对象",{"2":{"16":1}}],["parse",{"0":{"16":1}}],["prototype",{"0":{"13":1,"14":1}}],["person",{"2":{"11":3}}],["y",{"2":{"12":2}}],["yu",{"2":{"3":3}}],["x",{"2":{"12":3}}],["x3c",{"2":{"5":14}}],["的功能相同",{"2":{"12":1}}],["的函数中存在函数",{"2":{"3":1}}],["它提供了一种非常方便的方式来执行浅拷贝",{"2":{"12":1}}],["es2015特性",{"2":{"12":1}}],["es6",{"2":{"12":1}}],["展开运算符是一个",{"2":{"12":1}}],["展开运算符",{"0":{"12":1}}],["41",{"2":{"11":2}}],["然后返回目标对象",{"2":{"11":1}}],["方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象",{"2":{"11":1}}],["方式",{"2":{"9":1}}],["obj2",{"2":{"11":3,"12":2}}],["obj1",{"2":{"11":3,"12":4}}],["object",{"0":{"11":1},"2":{"11":2,"12":1}}],["ok",{"2":{"3":1}}],["改变不会使原数据一同改变",{"2":{"9":3}}],["改变会使原数据一同改变",{"2":{"9":3}}],["否",{"2":{"9":2}}],["否则游离的子树无法释放",{"2":{"5":1}}],["是",{"2":{"9":1}}],["原数据中包含子对象",{"2":{"9":1}}],["第一层数据为基本数据类型",{"2":{"9":1}}],["和原数据是否指向同一对象",{"2":{"9":1}}],["对对象中的子对象进行递归拷贝",{"2":{"9":1}}],["对分配到的内存进行读",{"2":{"0":1}}],["拷贝前后的两个对象互不影响",{"2":{"9":1}}],["拷贝前后对象的基本数据类型互不影响",{"2":{"9":1}}],["拷贝的就是内存地址",{"2":{"8":1}}],["拷贝的就是基本类型的值",{"2":{"8":1}}],["重新在堆中创建内存",{"2":{"9":1}}],["两个对象是联动的",{"2":{"9":1}}],["因为这两者基于json",{"2":{"16":1}}],["因为返回的函数中并没有对",{"2":{"3":1}}],["因此",{"2":{"9":1}}],["其实都是改变的存储空间的内容",{"2":{"9":1}}],["其实在函数调用后",{"2":{"3":1}}],["无论哪个对象发生改变",{"2":{"9":1}}],["赋值",{"2":{"9":1}}],["赋值和深",{"0":{"9":1}}],["赋的其实是该对象的在栈中的地址",{"2":{"9":1}}],["不过比较的前提都是针对引用类型",{"2":{"9":1}}],["不然的话数据量越来越大",{"2":{"4":1}}],["修改新对象不会改到原对象",{"2":{"8":1}}],["总而言之",{"2":{"8":1}}],["新的对象产生了",{"2":{"16":1}}],["新对象跟原对象不共享内存",{"2":{"8":2}}],["新旧对象还是共享同一块内存",{"2":{"8":2}}],["浅拷贝的实现方式",{"0":{"10":1},"1":{"11":1,"12":1,"13":1,"14":1}}],["浅拷贝的区别",{"0":{"9":1}}],["浅拷贝",{"2":{"9":2}}],["浅拷贝只复制指向某个对象的指针",{"2":{"8":1}}],["浅拷贝方法",{"2":{"8":1}}],["浅拷贝是创建一个新对象",{"2":{"8":1}}],["var",{"2":{"8":2,"20":3}}],["basketball",{"2":{"11":2}}],["b",{"2":{"8":5,"11":2,"12":1,"13":2,"14":2,"20":1}}],["a++",{"2":{"20":1}}],["arr3",{"2":{"14":2}}],["arr2",{"2":{"13":2}}],["arr",{"2":{"13":3,"14":3}}],["array",{"0":{"13":1,"14":1},"2":{"3":3,"4":2}}],["address",{"2":{"12":3}}],["age",{"2":{"11":2}}],["a",{"2":{"11":1,"12":2,"13":1,"14":1,"20":2}}],["assign",{"0":{"11":1},"2":{"11":2,"12":1}}],["a3",{"2":{"8":3}}],["a2",{"2":{"8":2}}],["a1",{"2":{"8":4}}],["且修改新对象不会影响原对象",{"2":{"8":1}}],["从堆内存中开辟一个新的区域存放新对象",{"2":{"8":1,"9":1}}],["深拷贝的实现方式",{"0":{"15":1},"1":{"16":1,"17":1}}],["深拷贝",{"2":{"9":2}}],["深拷贝方法",{"2":{"8":1}}],["深拷贝是将一个对象从内存中完整的拷贝一份出来",{"2":{"8":1}}],["深拷贝与浅拷贝",{"0":{"8":1},"1":{"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1}}],["就会影响到另一个对象",{"2":{"8":1}}],["就会导致该变量在全局创建",{"2":{"4":1}}],["控制台的打印",{"0":{"7":1}}],["来取消使用",{"2":{"6":1}}],["也存在这个问题",{"2":{"6":1}}],["也就是两个对象指向的是同一个存储空间",{"2":{"9":1}}],["也就是说当我们在使用全局变量存储数据时",{"2":{"4":1}}],["也就是说",{"2":{"3":1}}],["也就会出现内存泄漏",{"2":{"5":1}}],["也就造成了内存泄漏",{"2":{"3":1}}],["浏览器中的",{"2":{"6":1}}],["另外",{"2":{"6":1}}],["c不在闭包中",{"2":{"20":1}}],["concat",{"0":{"13":1},"2":{"13":1}}],["const",{"2":{"11":1,"12":1,"13":1,"14":1}}],["console",{"2":{"3":3,"11":1,"12":1,"13":1,"14":1}}],["c",{"2":{"8":5,"20":1}}],["cancelanimationframe",{"2":{"6":1}}],["cleartimeout来清除",{"2":{"6":1}}],["clearinterval",{"2":{"6":1}}],["最好调用",{"2":{"6":1}}],["时",{"2":{"6":1}}],["时会使用变量缓存",{"2":{"5":1}}],["true",{"2":{"8":1}}],["timeout",{"2":{"6":1}}],["test",{"2":{"3":10,"4":2,"20":2}}],["或者",{"2":{"6":2}}],["increase",{"2":{"20":2}}],["interval",{"2":{"6":1}}],["id=",{"2":{"5":3}}],["回调函数里的变量以及回调函数本身都无法被回收",{"2":{"6":1}}],["遗忘的定时器",{"0":{"6":1}}],["解决办法就是将引用子节点的变量也置空",{"2":{"5":1}}],["还是会出现内存泄漏",{"2":{"5":1}}],["假如我们将父节点置空",{"2":{"5":1}}],["gc",{"2":{"5":1}}],["依然进行不了",{"2":{"5":1}}],["节点树下整个游离节点树均无法清理",{"2":{"5":1}}],["节点引用后删除了节点",{"2":{"5":1}}],["节点的引用",{"2":{"5":1}}],["当我们把一个对象赋值给一个新的变量时",{"2":{"9":1}}],["当我们使用变量缓存",{"2":{"5":1}}],["当不需要",{"2":{"6":1}}],["当然也很简单",{"2":{"4":1}}],["已无变量引用",{"2":{"5":1}}],["虽置空了ul变量",{"2":{"5":1}}],["整个ul及其子元素都不能gc",{"2":{"5":1}}],["由于ul变量存在",{"2":{"5":1}}],["queryselector",{"2":{"5":3}}],["stringify和json",{"2":{"16":1}}],["stringify将对象转成json字符串",{"2":{"16":1}}],["stringify",{"0":{"16":1}}],["slice",{"0":{"14":1},"2":{"14":1}}],["sports",{"2":{"11":3}}],["shallowclone",{"2":{"8":1}}],["script>",{"2":{"5":2}}],["something",{"2":{"4":1}}],[">",{"2":{"5":3}}],["requestanimationframe",{"2":{"6":1}}],["removechild",{"2":{"5":1}}],["return",{"2":{"3":6,"20":1}}],["root",{"2":{"5":4}}],["deepclone",{"2":{"8":1}}],["div>",{"2":{"5":1}}],["div",{"2":{"5":1}}],["document",{"2":{"5":3}}],["dom",{"2":{"5":4}}],["do",{"2":{"4":1}}],["html",{"2":{"5":1}}],["但如果滥用闭包或不当使用",{"2":{"21":1}}],["但不能处理函数和正则",{"2":{"16":1}}],["但拷贝前后对象的引用类型因共享同一块内存",{"2":{"9":1}}],["但深拷贝会另外创造一个一模一样的对象",{"2":{"8":1}}],["但是在生产环境下",{"2":{"7":1}}],["但是被删除的父节点其子节点引用也缓存在变量里",{"2":{"5":1}}],["但是它并没有造成内存泄漏",{"2":{"3":1}}],["但由于li3变量引用ul的子节点",{"2":{"5":1}}],["但移除节点的时候",{"2":{"5":1}}],["考虑到性能或代码简洁方面",{"2":{"5":1}}],["游离的dom节点",{"0":{"5":1}}],["我们需要在不需要的时候用",{"2":{"6":1}}],["我们应该同步释放缓存的引用",{"2":{"5":1}}],["我们代码中进行",{"2":{"5":1}}],["我们一定要记得设置存储上限并及时清理",{"2":{"4":1}}],["我们在程序中也会不可避免的使用全局变量",{"2":{"4":1}}],["特别是在使用全局变量做持续存储大量数据的缓存时",{"2":{"4":1}}],["即使函数执行完毕",{"2":{"21":1}}],["即可",{"2":{"4":1}}],["即访问并使用变量",{"2":{"0":1}}],["在",{"2":{"19":1}}],["在了解闭包之前可以先去了解词法环境",{"2":{"18":1}}],["在开发环境下",{"2":{"7":1}}],["在定时器没有结束前",{"2":{"6":1}}],["在使用完将其置为",{"2":{"4":1}}],["在声明变量",{"2":{"0":1}}],["要确保使用后将其置空或者重新分配",{"2":{"4":1}}],["这使得这些变量对外部是不可见的",{"2":{"21":1}}],["这意味着闭包可以记住函数执行时的上下文环境",{"2":{"21":1}}],["这里的自由变量是外部函数作用域中的变量",{"2":{"19":1}}],["这里就不深度解读闭包了",{"2":{"18":1}}],["这种方法虽然可以实现数组或对象深拷贝",{"2":{"16":1}}],["这也是利用json",{"2":{"16":1}}],["这也就需要我们额外的关注",{"2":{"4":1}}],["这与",{"2":{"12":1}}],["这三者的区别如下",{"2":{"9":1}}],["这个对象有着原始对象属性值的一份精确拷贝",{"2":{"8":1}}],["这些全局变量除非被取消或者重新分配之外也是无法回收的",{"2":{"4":1}}],["这一现象就被称为内存泄漏",{"2":{"1":1}}],["又因为是全局变量",{"2":{"4":1}}],["此时可以gc",{"2":{"5":1}}],["此时这种情况就会在全局自动创建一个变量name",{"2":{"4":1}}],["此处变量name未被声明",{"2":{"4":1}}],["却直接对某变量进行赋值",{"2":{"4":1}}],["例如未声明变量",{"2":{"4":1}}],["只是有时候会因为疏忽而导致某些变量流失到全局",{"2":{"4":1}}],["全局的变量一般是不会被垃圾回收掉的当然这并不是说变量都不能存在全局",{"2":{"4":1}}],["全局变量",{"0":{"4":1}}],["name",{"2":{"4":1,"11":3,"12":3}}],["null",{"2":{"3":1,"4":2,"5":2}}],["new",{"2":{"3":3,"4":2}}],["如内存占用过高",{"2":{"21":1}}],["如果属性是引用类型",{"2":{"8":1}}],["如果属性是基本类型",{"2":{"8":1}}],["如果不将缓存引用的变量置空",{"2":{"5":1}}],["如果某一块内存空间在使用后未被释放",{"2":{"1":1}}],["如上所示",{"2":{"5":1}}],["如下所示",{"2":{"4":1}}],["如下",{"2":{"3":1}}],["把外部的引用关系置空就好了",{"2":{"3":1}}],["那么就会导致整个父",{"2":{"5":1}}],["那么怎样解决呢",{"2":{"3":1}}],["那我们再来看",{"2":{"3":1}}],["并将其保留在内存中",{"2":{"21":1}}],["并将一个很大的数组赋值给name",{"2":{"4":1}}],["并不会被回收",{"2":{"3":1}}],["并且因为",{"2":{"3":1}}],["并且持续累积",{"2":{"1":1}}],["并且在不使用变量的时候",{"2":{"1":1}}],["所以如果其中一个对象改变了这个地址",{"2":{"8":1}}],["所以ul元素依然不能被gc",{"2":{"5":1}}],["所以该内存空间就一直不会被释放",{"2":{"4":1}}],["所以",{"2":{"3":1}}],["显然它也是闭包",{"2":{"3":1}}],["内部的",{"2":{"3":1}}],["内存压力也会随之增高",{"2":{"4":1}}],["内存使用完毕后",{"2":{"0":1}}],["内存使用",{"2":{"0":1}}],["内存分配",{"2":{"0":1}}],["内存其实就是程序在运行时",{"2":{"0":1}}],["内存泄漏",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1}}],["上面这个例子是一个典型闭包",{"2":{"3":1}}],["li3",{"2":{"5":4}}],["li",{"2":{"5":1}}],["li>",{"2":{"5":7}}],["log",{"2":{"3":3,"11":1,"12":1,"13":1,"14":1}}],["let",{"2":{"3":6,"5":3}}],["football",{"2":{"11":1}}],["false",{"2":{"8":1}}],["fn2child",{"2":{"3":5}}],["fn2",{"2":{"3":5}}],["fn1child",{"2":{"3":2}}],["fn1",{"2":{"3":4,"4":2}}],["function",{"2":{"3":3,"20":1}}],["fill",{"2":{"3":3}}],["===",{"2":{"8":2}}],["=",{"2":{"3":7,"4":3,"5":5,"8":3,"11":4,"12":4,"13":3,"14":3,"20":3}}],["常见的内存泄漏",{"0":{"2":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1}}],["直观体现就是程序卡死",{"2":{"1":1}}],["直至用尽全部的内存空间",{"2":{"1":1}}],["程序将无法正常运行",{"2":{"1":1}}],["每一个程序的运行都需要一块内存空间",{"2":{"1":1}}],["每一块内存都有对应的生命周期",{"2":{"0":1}}],["自动",{"2":{"1":1}}],["都实现了给变量自动分配内存",{"2":{"1":1}}],["释放掉不再被使用的内存",{"2":{"0":1}}],["释放内存",{"2":{"0":1,"1":1}}],["函数",{"2":{"3":1}}],["函数内部的引用",{"2":{"3":1}}],["函数等",{"2":{"0":1}}],["函数时",{"2":{"0":1}}],["写操作",{"2":{"0":1}}],["系统崩溃",{"2":{"1":1}}],["系统分配的内存空间",{"2":{"0":1}}],["系统为其分配的一块存储空间",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
